{% comment %}
  NUSENSE TryON Script - Shopify Liquid Template
  Include this script to load the NUSENSE TryON widget functionality
{% endcomment %}

{% unless nusense_tryon_disabled %}
  <script>
    // NUSENSE TryON Configuration
    window.NUSENSE_CONFIG = {
      widgetUrl: '{{ settings.nusense_widget_url | default: "https://try-this-look.vercel.app" }}',
      debug: {{ settings.nusense_debug | default: true }},
      buttonSelector: '{{ settings.nusense_button_selector | default: "#nusense-tryon-btn" }}',
      autoDetect: {{ settings.nusense_auto_detect | default: true }},
      theme: '{{ settings.nusense_theme | default: "default" }}'
    };

    // Initialize image extraction listener for iframe communication
    (function() {
      // Extract product images from the current page
      function extractProductImages() {
        const images = [];
        const seenUrls = new Set();

        // Helper to add image if valid and not duplicate
        function addImage(url, metadata) {
          if (!url || seenUrls.has(url)) return;
          
          const cleanUrl = cleanImageUrl(url);
          if (!cleanUrl || seenUrls.has(cleanUrl)) return;
          
          if (isValidProductImageUrl(cleanUrl, metadata)) {
            images.push(cleanUrl);
            seenUrls.add(cleanUrl);
          }
        }

        // Clean and normalize image URL
        function cleanImageUrl(url) {
          if (!url || typeof url !== 'string') return null;
          
          try {
            const urlObj = new URL(url, window.location.href);
            const keepParams = ['quality', 'format'];
            const params = new URLSearchParams();
            
            for (const [key, value] of urlObj.searchParams.entries()) {
              if (keepParams.includes(key.toLowerCase())) {
                params.set(key, value);
              }
            }
            
            urlObj.search = params.toString();
            return urlObj.href;
          } catch {
            return url;
          }
        }

        // Validate if an image URL is likely a product image
        function isValidProductImageUrl(url, metadata) {
          if (!url) return false;
          
          const lowerUrl = url.toLowerCase();
          const lowerAlt = (metadata?.alt || '').toLowerCase();
          
          const excludePatterns = [
            'logo', 'icon', 'badge', 'payment', 'trust', 'review', 'star',
            'avatar', 'user', 'profile', 'social', 'facebook', 'twitter',
            'instagram', 'pinterest', 'google', 'analytics', 'tracking',
            'pixel', 'spacer', 'blank', 'placeholder', '1x1', 'pixel.gif',
            'transparent', '.svg'
          ];

          for (const pattern of excludePatterns) {
            if (lowerUrl.includes(pattern) || lowerAlt.includes(pattern)) {
              return false;
            }
          }

          const validExtensions = ['.jpg', '.jpeg', '.png', '.webp', '.gif', '.avif'];
          const hasValidExtension = validExtensions.some(ext => lowerUrl.includes(ext));
          
          if (metadata) {
            const { width, height } = metadata;
            if (width && height && width < 150 && height < 150) {
              return false;
            }
          }

          try {
            new URL(url, window.location.href);
          } catch {
            return false;
          }

          return true;
        }

        // Extract from all img elements
        const imgElements = document.querySelectorAll('img');
        imgElements.forEach(img => {
          const sources = [
            img.src,
            img.dataset.src,
            img.dataset.lazySrc,
            img.dataset.originalSrc,
            img.dataset.productImage,
            img.currentSrc,
            img.getAttribute('data-original'),
            img.getAttribute('data-lazy'),
          ].filter(Boolean);

          if (img.srcset) {
            const srcsetUrls = img.srcset.split(',').map(entry => {
              const parts = entry.trim().split(/\s+/);
              return parts[0];
            }).filter(Boolean);
            sources.push(...srcsetUrls);
          }

          sources.forEach(src => {
            addImage(src, {
              width: img.naturalWidth || img.width,
              height: img.naturalHeight || img.height,
              alt: img.alt,
            });
          });
        });

        // Extract from Shopify-specific selectors
        const shopifySelectors = [
          '.product__media img', '.product-image img', '.product-gallery img',
          '.product-photos img', '.product__media-wrapper img', '.product-single__media img',
          '[data-product-image] img', '[data-product-single-media-group] img',
          '.product-images img', '.product-media img', '.flickity-slider img',
          '.swiper-slide img', '.carousel img', '.product-thumbnails img', '.thumbnail img'
        ];

        shopifySelectors.forEach(selector => {
          document.querySelectorAll(selector).forEach(img => {
            if (img instanceof HTMLImageElement) {
              const sources = [
                img.src, img.dataset.src, img.dataset.lazySrc, img.currentSrc
              ].filter(Boolean);
              
              sources.forEach(src => {
                addImage(src, {
                  width: img.naturalWidth || img.width,
                  height: img.naturalHeight || img.height,
                  alt: img.alt,
                });
              });
            }
          });
        });

        return images;
      }

      // Extract all images from the page that are NOT main product images
      // This finds any images on the page and filters out the main product images
      function extractRecommendedProductsImages(mainProductImages) {
        const allImages = [];
        const seenUrls = new Set();
        const seenNormalizedUrls = new Set(); // Track normalized URLs (without query params) for better deduplication
        const mainProductImageSet = new Set();
        const mainProductImageBasePaths = new Set(); // Track base image paths for better matching

        // Helper to extract base image path (filename without query params or CDN variations)
        function getBaseImagePath(url) {
          try {
            const urlObj = new URL(url, window.location.origin);
            urlObj.search = '';
            urlObj.hash = '';
            const path = urlObj.pathname;
            
            // Extract just the filename or last part of path
            const pathParts = path.split('/');
            const filename = pathParts[pathParts.length - 1];
            
            // Also get a shorter path (last 2 parts) for better matching
            if (pathParts.length >= 2) {
              const shortPath = pathParts.slice(-2).join('/');
              return shortPath.toLowerCase();
            }
            
            return filename.toLowerCase();
          } catch (e) {
            return null;
          }
        }

        // Helper to normalize URL for comparison (remove query params)
        function normalizeUrlForComparison(url) {
          try {
            const urlObj = new URL(url, window.location.origin);
            urlObj.search = ''; // Remove query params
            urlObj.hash = ''; // Remove hash
            return urlObj.href.toLowerCase();
          } catch (e) {
            return null;
          }
        }

        // Normalize main product images for comparison - add all variations
        if (mainProductImages && Array.isArray(mainProductImages)) {
          mainProductImages.forEach(function(img) {
            try {
              const urlObj = new URL(img, window.location.origin);
              const absUrl = urlObj.href;
              
              // Add the absolute URL
              mainProductImageSet.add(absUrl.toLowerCase());
              
              // Add normalized URL (without query params)
              const normalizedForComparison = normalizeUrlForComparison(absUrl);
              if (normalizedForComparison) {
                mainProductImageSet.add(normalizedForComparison);
              }
              
              // Add base image path
              const basePath = getBaseImagePath(absUrl);
              if (basePath) {
                mainProductImageBasePaths.add(basePath);
              }
            } catch (e) {
              // Try to normalize the original URL anyway
              try {
                const normalizedForComparison = normalizeUrlForComparison(img);
                if (normalizedForComparison) {
                  mainProductImageSet.add(normalizedForComparison);
                }
                const basePath = getBaseImagePath(img);
                if (basePath) {
                  mainProductImageBasePaths.add(basePath);
                }
              } catch (e) {}
            }
          });
        }

        // Helper to add image if valid and not duplicate
        function addImage(url) {
          if (!url) return;
          
          try {
            const urlObj = new URL(url, window.location.origin);
            const absUrl = urlObj.href;
            
            // Normalize URL for comparison (without query params)
            const normalizedForComparison = normalizeUrlForComparison(absUrl);
            if (!normalizedForComparison) return;
            
            // Check if we've already seen this normalized URL (deduplication)
            if (seenNormalizedUrls.has(normalizedForComparison)) {
              return; // Already added this image (duplicate)
            }
            
            // Also check the full URL
            if (seenUrls.has(absUrl.toLowerCase())) {
              return;
            }
            
            // Check if this is a main product image - check multiple variations
            let isMainProductImage = false;
            
            // Check full URL
            if (mainProductImageSet.has(absUrl.toLowerCase()) || 
                mainProductImageSet.has(normalizedForComparison) ||
                mainProductImageSet.has(url.toLowerCase())) {
              isMainProductImage = true;
            }
            
            // Check base image path (filename)
            if (!isMainProductImage) {
              const basePath = getBaseImagePath(absUrl);
              if (basePath && mainProductImageBasePaths.has(basePath)) {
                isMainProductImage = true;
              }
            }
            
            // Double-check by comparing with all main product images using base path
            if (!isMainProductImage && mainProductImages && mainProductImages.length > 0) {
              const currentBasePath = getBaseImagePath(absUrl);
              if (currentBasePath) {
                for (var i = 0; i < mainProductImages.length; i++) {
                  const mainImg = mainProductImages[i];
                  const mainBasePath = getBaseImagePath(mainImg);
                  if (mainBasePath && mainBasePath === currentBasePath) {
                    isMainProductImage = true;
                    break;
                  }
                }
              }
            }
            
            // Skip if it's a main product image
            if (isMainProductImage) {
              console.log('NUSENSE: Skipping main product image from recommended:', absUrl);
              return;
            }
            
            // Basic validation: must be a valid image URL
            if (absUrl.match(/\.(jpg|jpeg|png|webp|gif|avif)(\?|$)/i)) {
              // Exclude common non-product images
              const lowerUrl = absUrl.toLowerCase();
              const excludePatterns = [
                'logo', 'icon', 'badge', 'payment', 'trust', 'review', 'star',
                'avatar', 'user', 'profile', 'social', 'facebook', 'twitter',
                'instagram', 'pinterest', 'google', 'analytics', 'tracking',
                'pixel', 'spacer', 'blank', 'placeholder', '1x1', 'pixel.gif',
                'transparent', '.svg'
              ];
              
              const shouldExclude = excludePatterns.some(function(pattern) {
                return lowerUrl.includes(pattern);
              });
              if (shouldExclude) return;
              
              allImages.push(absUrl);
              seenUrls.add(absUrl.toLowerCase());
              seenUrls.add(url.toLowerCase());
              seenNormalizedUrls.add(normalizedForComparison);
            }
          } catch (e) {
            // Skip invalid URLs
          }
        }

        try {
          // Extract ALL images from the page
          const allImgElements = document.querySelectorAll('img');
          allImgElements.forEach(function(img) {
            if (img instanceof HTMLImageElement) {
              const sources = [
                img.src,
                img.dataset.src,
                img.dataset.lazySrc,
                img.dataset.originalSrc,
                img.dataset.productImage,
                img.currentSrc,
                img.getAttribute('data-original'),
                img.getAttribute('data-lazy')
              ].filter(Boolean);

              // Extract from srcset
              if (img.srcset) {
                const srcsetEntries = img.srcset.split(',');
                srcsetEntries.forEach(function(entry) {
                  const parts = entry.trim().split(/\s+/);
                  if (parts[0]) {
                    sources.push(parts[0]);
                  }
                });
              }

              sources.forEach(function(src) {
                addImage(src);
              });
            }
          });

          // Also check background images
          const bgImageElements = document.querySelectorAll('[style*="background-image"]');
          bgImageElements.forEach(function(el) {
            const style = window.getComputedStyle(el);
            const bgImage = style.backgroundImage;
            if (bgImage && bgImage !== 'none') {
              const urlMatch = bgImage.match(/url\(['"]?([^'"]+)['"]?\)/);
              if (urlMatch && urlMatch[1]) {
                addImage(urlMatch[1]);
              }
            }
          });

          if (allImages.length > 0) {
            console.log('NUSENSE: Extracted', allImages.length, 'non-product images as recommended products');
          }
        } catch (e) {
          console.error('NUSENSE: Error extracting recommended products images', e);
        }

        return allImages;
      }

      // Listen for image requests from iframe
      window.addEventListener("message", (event) => {
        if (event.data && event.data.type === "NUSENSE_REQUEST_IMAGES") {
          console.log('NUSENSE: Received image request from iframe');
          
          let images = [];
          let recommendedImages = [];
          
          // Priority 1: Use NUSENSE_PRODUCT_DATA if available (most reliable)
          if (window.NUSENSE_PRODUCT_DATA && window.NUSENSE_PRODUCT_DATA.images) {
            images = Array.isArray(window.NUSENSE_PRODUCT_DATA.images) 
              ? window.NUSENSE_PRODUCT_DATA.images 
              : [];
            console.log('NUSENSE: Using images from NUSENSE_PRODUCT_DATA:', images.length);
          }
          
          // Priority 2: Extract from page if NUSENSE_PRODUCT_DATA not available or empty
          if (images.length === 0) {
            images = extractProductImages();
            console.log('NUSENSE: Extracted images from page:', images.length);
          }

          // Extract all other images from the page that are NOT main product images
          recommendedImages = extractRecommendedProductsImages(images);
          console.log('NUSENSE: Extracted recommended products images (non-product images):', recommendedImages.length);
          
          // Send images back to iframe
          if (event.source && event.source !== window) {
            console.log('NUSENSE: Sending', images.length, 'main images and', recommendedImages.length, 'recommended images to iframe');
            (event.source).postMessage({
              type: "NUSENSE_PRODUCT_IMAGES",
              images: images,
              recommendedImages: recommendedImages
            }, "*");
          } else {
            console.warn('NUSENSE: Invalid event source for image request');
          }
        }
      });

      console.log('NUSENSE TryON: Image extraction listener initialized on parent window');
    })();
  </script>

  <script src="{{ settings.nusense_widget_url | default: 'https://try-this-look.vercel.app' }}/nusense-tryon-widget.js" 
          async 
          defer
          onload="console.log('NUSENSE TryON Widget loaded successfully')"
          onerror="console.error('Failed to load NUSENSE TryON Widget')">
  </script>

  <style>
    /* NUSENSE TryON Widget Styles */
    .nusense-tryon-button {
      font-family: inherit;
      font-size: clamp(14px, 1.6vw, 16px);
      padding: clamp(10px, 2.5vw, 12px) clamp(16px, 4vw, 24px);
      transition: all 0.2s ease;
    }
    
    .nusense-tryon-button:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    
    .nusense-tryon-button:active {
      transform: scale(0.98);
    }
    
    /* Mobile responsiveness */
    @media (max-width: 768px) {
      .nusense-tryon-button {
        width: 100%;
        justify-content: center;
        margin: 10px 0;
      }
    }
    
    /* Theme customizations */
    {% if settings.nusense_theme == 'minimal' %}
      .nusense-tryon-button {
        background: #000 !important;
        border: 2px solid #000 !important;
      }
      .nusense-tryon-button:hover {
        background: #333 !important;
        border-color: #333 !important;
      }
    {% elsif settings.nusense_theme == 'colorful' %}
      .nusense-tryon-button {
        background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4) !important;
        background-size: 300% 300% !important;
        animation: gradientShift 3s ease infinite !important;
      }
      @keyframes gradientShift {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
      }
    {% endif %}
  </style>
{% endunless %}
