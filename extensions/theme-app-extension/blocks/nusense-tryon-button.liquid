{% comment %}
  NUSENSE TryON Button Block
  This block can be added to product pages via the theme editor
{% endcomment %}

{% schema %}
{
  "name": "NUSENSE Try-On Button",
  "target": "section",
  "settings": [
    {
      "type": "text",
      "id": "button_text",
      "label": "Button Text",
      "default": "Try Now"
    },
    {
      "type": "select",
      "id": "button_style",
      "label": "Button Style",
      "options": [
        {
          "value": "primary",
          "label": "Primary"
        },
        {
          "value": "secondary",
          "label": "Secondary"
        },
        {
          "value": "outline",
          "label": "Outline"
        },
        {
          "value": "minimal",
          "label": "Minimal"
        }
      ],
      "default": "primary"
    },
    {
      "type": "checkbox",
      "id": "show_icon",
      "label": "Show Icon",
      "default": true
    },
    {
      "type": "text",
      "id": "button_icon",
      "label": "Button Icon (emoji)",
      "default": "✨"
    },
    {
      "type": "checkbox",
      "id": "button_width_full",
      "label": "Full Width Button",
      "default": true,
      "info": "Enable to make button full width. Disable to allow flexible width (can be placed next to other buttons)"
    }
  ]
}
{% endschema %}

{% comment %}
  Read all block settings with proper defaults
  Checkboxes return true/false or nil, so we need to handle them properly
{% endcomment %}
{% assign button_text = block.settings.button_text | default: 'Try Now' %}
{% assign button_style = block.settings.button_style | default: 'primary' %}
{% assign button_icon = block.settings.button_icon | default: '✨' %}

{% comment %}
  Handle checkbox values - they can be true, false, or nil
{% endcomment %}
{% if block.settings.show_icon == true or block.settings.show_icon == 'true' %}
  {% assign show_icon = true %}
{% else %}
  {% assign show_icon = false %}
{% endif %}

{% if block.settings.button_width_full == true or block.settings.button_width_full == 'true' %}
  {% assign button_width_full = true %}
{% else %}
  {% assign button_width_full = false %}
{% endif %}

{% comment %}
  Build button classes based on style variant
  Shopify themes typically use: button, button--secondary, button--outline, button--tertiary
{% endcomment %}
{% assign button_classes = 'button' %}
{% case button_style %}
  {% when 'secondary' %}
    {% assign button_classes = button_classes | append: ' button--secondary' %}
  {% when 'outline' %}
    {% assign button_classes = button_classes | append: ' button--outline' %}
  {% when 'minimal' %}
    {% assign button_classes = button_classes | append: ' button--tertiary' %}
  {% else %}
    {% comment %} Primary - no additional class needed {% endcomment %}
{% endcase %}
{% if button_width_full %}
  {% assign button_classes = button_classes | append: ' button--full-width' %}
{% endif %}

<button 
  id="nusense-tryon-btn-{{ block.id }}" 
  class="{{ button_classes }}"
  {{ block.shopify_attributes }}
  aria-label="{{ button_text }}"
  data-product-id="{{ product.id }}"
  data-shop-domain="{{ shop.permanent_domain }}"
  data-button-style="{{ button_style }}"
  data-show-icon="{{ show_icon }}"
  data-button-width-full="{{ button_width_full }}"
  type="button"
  style="display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem;{% if button_width_full %} width: 100%;{% endif %}"
>
  <span class="button__icon" data-icon="{{ button_icon }}" style="{% unless show_icon %}display: none;{% endunless %}">{{ button_icon }}</span>
  <span class="button__text">{{ button_text }}</span>
</button>

<script>
  (function() {
    const button = document.getElementById('nusense-tryon-btn-{{ block.id }}');
    if (!button) return;
    
    // Function to apply all button configurations
    const applyButtonConfig = function() {
      // Get all settings from data attributes
      const buttonStyle = button.dataset.buttonStyle || '{{ button_style }}' || 'primary';
      const showIcon = button.dataset.showIcon === 'true' || button.dataset.showIcon === true;
      const buttonWidthFull = button.dataset.buttonWidthFull === 'true' || button.dataset.buttonWidthFull === true;
      
      // Apply button style classes
      let classes = button.className
        .replace(/\s*button--secondary\s*/g, ' ')
        .replace(/\s*button--outline\s*/g, ' ')
        .replace(/\s*button--tertiary\s*/g, ' ')
        .replace(/\s*button--full-width\s*/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
      
      // Ensure base button class is present
      if (!classes.includes('button')) {
        classes = 'button ' + classes;
      }
      
      // Apply style variant
      if (buttonStyle === 'secondary') {
        classes += ' button--secondary';
      } else if (buttonStyle === 'outline') {
        classes += ' button--outline';
      } else if (buttonStyle === 'minimal') {
        classes += ' button--tertiary';
      }
      
      // Apply full width class
      if (buttonWidthFull) {
        classes += ' button--full-width';
      }
      
      button.className = classes.trim();
      
      // Apply width style
      if (buttonWidthFull) {
        button.style.width = '100%';
      } else {
        button.style.width = '';
      }
      
      // Handle icon visibility and text
      const iconSpan = button.querySelector('.button__icon');
      if (iconSpan) {
        iconSpan.style.display = showIcon ? 'inline' : 'none';
        // Update icon text if data attribute exists
        const iconText = iconSpan.dataset.icon || '{{ button_icon }}';
        if (iconText && iconSpan.textContent !== iconText) {
          iconSpan.textContent = iconText;
        }
      }
      
      console.log('NUSENSE Config Applied:', {
        style: buttonStyle,
        showIcon: showIcon,
        fullWidth: buttonWidthFull,
        iconText: iconSpan ? iconSpan.textContent : 'N/A',
        classes: button.className
      });
    };
    
    // Apply configuration on load
    applyButtonConfig();
    
    // Watch for changes in the theme editor
    const observer = new MutationObserver(function(mutations) {
      let shouldUpdate = false;
      mutations.forEach(function(mutation) {
        if (mutation.type === 'attributes') {
          const attrName = mutation.attributeName;
          if (attrName === 'data-button-style' || 
              attrName === 'data-show-icon' || 
              attrName === 'data-button-width-full' ||
              attrName === 'class') {
            shouldUpdate = true;
          }
        }
      });
      if (shouldUpdate) {
        applyButtonConfig();
      }
    });
    
    observer.observe(button, {
      attributes: true,
      attributeFilter: ['data-button-style', 'data-show-icon', 'data-button-width-full', 'class'],
      subtree: true
    });
    
    // Also check periodically for theme editor updates
    let lastConfig = JSON.stringify({
      style: button.dataset.buttonStyle,
      showIcon: button.dataset.showIcon,
      fullWidth: button.dataset.buttonWidthFull
    });
    
    const configChecker = setInterval(function() {
      const currentConfig = JSON.stringify({
        style: button.dataset.buttonStyle,
        showIcon: button.dataset.showIcon,
        fullWidth: button.dataset.buttonWidthFull
      });
      
      if (currentConfig !== lastConfig) {
        lastConfig = currentConfig;
        applyButtonConfig();
      }
    }, 500);
    
    // Clean up on page unload
    window.addEventListener('beforeunload', function() {
      observer.disconnect();
      clearInterval(configChecker);
    });
    
    const productId = button.dataset.productId;
    const shopDomain = button.dataset.shopDomain;
    
    button.addEventListener('click', function() {
      // Open widget in modal or iframe
      // App proxy URL format: /apps/apps/a/{path}
      // Or use direct app URL if app proxy not needed
      const widgetUrl = '{{ shop.metafields.nusense.widget_url | default: "https://try-this-look.vercel.app" }}/widget?product_id=' + productId;
      
      // Save original body state BEFORE making any changes
      const originalOverflow = document.body.style.overflow;
      const originalPosition = document.body.style.position;
      const originalTop = document.body.style.top;
      const originalWidth = document.body.style.width;
      const scrollY = window.scrollY;
      
      // Prevent body scroll FIRST - before creating overlay
      document.body.style.overflow = 'hidden';
      document.body.style.position = 'fixed';
      document.body.style.top = `-${scrollY}px`;
      document.body.style.width = '100%';
      
      // Create modal overlay
      const overlay = document.createElement('div');
      overlay.id = 'nusense-widget-overlay';
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 999999;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
      `;
      
      // Block ALL clicks on overlay background - prevent closing
      const overlayClickHandler = function(e) {
        // Only allow clicks on iframe, block everything else
        if (e.target === overlay) {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
          return false;
        }
      };
      overlay.addEventListener('click', overlayClickHandler, true); // Use capture phase
      
      // Block all mouse events on overlay background
      const overlayMouseDownHandler = function(e) {
        if (e.target === overlay) {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
          return false;
        }
      };
      overlay.addEventListener('mousedown', overlayMouseDownHandler, true);
      
      const overlayMouseUpHandler = function(e) {
        if (e.target === overlay) {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
          return false;
        }
      };
      overlay.addEventListener('mouseup', overlayMouseUpHandler, true);
      
      const overlayContextMenuHandler = function(e) {
        if (e.target === overlay) {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
          return false;
        }
      };
      overlay.addEventListener('contextmenu', overlayContextMenuHandler, true);
      
      const iframe = document.createElement('iframe');
      iframe.src = widgetUrl;
      iframe.style.cssText = `
        width: 95vw;
        max-width: 1200px;
        height: 90vh;
        border: none;
        border-radius: 8px;
        background: white;
        pointer-events: auto;
      `;
      iframe.allow = 'camera; microphone';
      
      overlay.appendChild(iframe);
      document.body.appendChild(overlay);
      
      // NOW block all pointer events on body content (after overlay is appended)
      const bodyChildren = Array.from(document.body.children);
      bodyChildren.forEach(function(child) {
        if (child.id !== 'nusense-widget-overlay') {
          child.style.pointerEvents = 'none';
          child.style.userSelect = 'none';
        }
      });
      
      // Ensure overlay and iframe can receive events
      overlay.style.pointerEvents = 'auto';
      iframe.style.pointerEvents = 'auto';
      
      // Prevent ALL scroll events on document level
      const preventAllScroll = function(e) {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        return false;
      };
      
      // Block scroll events on overlay background
      overlay.addEventListener('wheel', preventAllScroll, { passive: false, capture: true });
      overlay.addEventListener('touchmove', preventAllScroll, { passive: false, capture: true });
      overlay.addEventListener('scroll', preventAllScroll, { passive: false, capture: true });
      const overlayTouchStartHandler = function(e) {
        if (e.target === overlay) {
          e.preventDefault();
          e.stopPropagation();
        }
      };
      overlay.addEventListener('touchstart', overlayTouchStartHandler, { passive: false, capture: true });
      
      // Block scroll on document level - block everything
      document.addEventListener('wheel', preventAllScroll, { passive: false, capture: true });
      document.addEventListener('touchmove', preventAllScroll, { passive: false, capture: true });
      document.addEventListener('scroll', preventAllScroll, { passive: false, capture: true });
      
      const documentTouchStartHandler = function(e) {
        // Only allow touch events on iframe
        if (!iframe.contains(e.target) && e.target !== iframe) {
          e.preventDefault();
          e.stopPropagation();
        }
      };
      document.addEventListener('touchstart', documentTouchStartHandler, { passive: false, capture: true });
      
      // Block keyboard events that might cause scrolling
      const preventKeyboardScroll = function(e) {
        // Block arrow keys, page up/down, space, etc.
        if ([32, 33, 34, 35, 36, 37, 38, 39, 40].indexOf(e.keyCode) !== -1) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
      };
      document.addEventListener('keydown', preventKeyboardScroll, { passive: false, capture: true });
      
      // Function to close widget and restore page state
      const closeWidget = function() {
        // Remove ALL event listeners
        overlay.removeEventListener('click', overlayClickHandler, true);
        overlay.removeEventListener('mousedown', overlayMouseDownHandler, true);
        overlay.removeEventListener('mouseup', overlayMouseUpHandler, true);
        overlay.removeEventListener('contextmenu', overlayContextMenuHandler, true);
        overlay.removeEventListener('wheel', preventAllScroll, true);
        overlay.removeEventListener('touchmove', preventAllScroll, true);
        overlay.removeEventListener('scroll', preventAllScroll, true);
        overlay.removeEventListener('touchstart', overlayTouchStartHandler, true);
        document.removeEventListener('wheel', preventAllScroll, true);
        document.removeEventListener('touchmove', preventAllScroll, true);
        document.removeEventListener('scroll', preventAllScroll, true);
        document.removeEventListener('touchstart', documentTouchStartHandler, true);
        document.removeEventListener('keydown', preventKeyboardScroll, true);
        
        // Restore body styles
        document.body.style.overflow = originalOverflow;
        document.body.style.position = originalPosition;
        document.body.style.top = originalTop;
        document.body.style.width = originalWidth;
        
        // Restore scroll position
        if (originalPosition !== 'fixed') {
          window.scrollTo(0, scrollY);
        }
        
        // Restore pointer events on body children
        bodyChildren.forEach(function(child) {
          if (child.id !== 'nusense-widget-overlay') {
            child.style.pointerEvents = '';
            child.style.userSelect = '';
          }
        });
        
        // Remove overlay
        if (overlay.parentNode) {
          overlay.parentNode.removeChild(overlay);
        }
        
        // Remove message listener
        window.removeEventListener('message', messageHandler);
      };
      
      // Listen for close messages from iframe
      const messageHandler = function(e) {
        if (e.data && e.data.type === 'NUSENSE_CLOSE_WIDGET') {
          closeWidget();
        }
      };
      window.addEventListener('message', messageHandler);
      
      // NO click outside handler - only close button can close
    });
  })();
</script>

